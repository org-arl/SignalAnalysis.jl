var documenterSearchIndex = {"docs":
[{"location":"generate.html#Generating-signals","page":"Generating signals","title":"Generating signals","text":"","category":"section"},{"location":"generate.html","page":"Generating signals","title":"Generating signals","text":"Modules = [SignalAnalysis]\nPages   = [\"generate.jl\"]","category":"page"},{"location":"generate.html#SignalAnalysis.chirp","page":"Generating signals","title":"SignalAnalysis.chirp","text":"chirp(freq1, freq2, duration)\nchirp(freq1, freq2, duration, fs; shape, phase, window)\n\n\nGenerates a frequency modulated chirp signal from freq1 to freq2 and specified duration at frame rate fs. The type of frequency modulation may be controlled using shape (:linear (default) or :hyperbolic). The starting phase and window type may be optionally specified.\n\nExamples:\n\njulia> x = chirp(5kHz, 7kHz, 100ms, 44.1kHz)\nSampledSignal @ 44100.0 Hz, 4410-element Array{Complex{Float64},1}:\n  ⋮\n\njulia> x = chirp(5kHz, 7kHz, 100ms, 44.1kHz; phase=45°, window=hamming)\nSampledSignal @ 44100.0 Hz, 4410-element Array{Complex{Float64},1}:\n  ⋮\n\njulia> x = chirp(5kHz, 7kHz, 100ms, 44.1kHz; shape=:hyperbolic, window=(tukey,0.05))\nSampledSignal @ 44100.0 Hz, 4410-element Array{Complex{Float64},1}:\n  ⋮\n\n\n\n\n\n","category":"function"},{"location":"generate.html#SignalAnalysis.cw-Tuple{Any, Any, Any}","page":"Generating signals","title":"SignalAnalysis.cw","text":"cw(freq, duration, fs; phase, window)\n\n\nGenerates a sinusoidal signal with specified freq and duration at frame rate fs. The starting phase and window type may be optionally specified.\n\nExamples:\n\njulia> x = cw(5kHz, 200ms, 44.1kHz)\nSampledSignal @ 44100.0 Hz, 8820-element Array{Complex{Float64},1}:\n  ⋮\n\njulia> x = cw(5kHz, 200ms, 44.1kHz; window=hamming)\nSampledSignal @ 44100.0 Hz, 8820-element Array{Complex{Float64},1}:\n  ⋮\n\njulia> x = cw(-5kHz, 200ms, 44.1kHz; phase=45°, window=(tukey, 0.05))\nSampledSignal @ 44100.0 Hz, 8820-element Array{Complex{Float64},1}:\n  ⋮\n\n\n\n\n\n","category":"method"},{"location":"iplot.html#Interactive-plotting","page":"Interactive plotting","title":"Interactive plotting","text":"","category":"section"},{"location":"iplot.html","page":"Interactive plotting","title":"Interactive plotting","text":"Interactive plots use InteractiveViz.jl to allow viewing of long signals.","category":"page"},{"location":"iplot.html","page":"Interactive plotting","title":"Interactive plotting","text":"Modules = [SignalAnalysis]\nPages   = [\"iplot.jl\"]","category":"page"},{"location":"basic.html#Basic-signal-analysis","page":"Basic signal analysis","title":"Basic signal analysis","text":"","category":"section"},{"location":"basic.html","page":"Basic signal analysis","title":"Basic signal analysis","text":"Modules = [SignalAnalysis]\nPages   = [\"basic.jl\"]","category":"page"},{"location":"basic.html#SignalAnalysis.energy-Tuple{AbstractVector{T} where T}","page":"Basic signal analysis","title":"SignalAnalysis.energy","text":"energy(s; fs)\n\n\nComputes total signal energy.\n\n\n\n\n\n","category":"method"},{"location":"basic.html#SignalAnalysis.ifrequency-Tuple{Any}","page":"Basic signal analysis","title":"SignalAnalysis.ifrequency","text":"ifrequency(s; fs)\n\n\nComputes instantaneous frequency of the signal.\n\n\n\n\n\n","category":"method"},{"location":"basic.html#SignalAnalysis.meanfrequency-Tuple{AbstractMatrix{T} where T}","page":"Basic signal analysis","title":"SignalAnalysis.meanfrequency","text":"meanfrequency(s; fs, nfft, window)\n\n\nComputes mean frequency of a signal.\n\n\n\n\n\n","category":"method"},{"location":"basic.html#SignalAnalysis.meantime-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Basic signal analysis","title":"SignalAnalysis.meantime","text":"meantime(s)\n\n\nComputes mean time of the signal.\n\n\n\n\n\n","category":"method"},{"location":"basic.html#SignalAnalysis.rmsbandwidth-Tuple{AbstractMatrix{T} where T}","page":"Basic signal analysis","title":"SignalAnalysis.rmsbandwidth","text":"rmsbandwidth(s; fs, nfft, window)\n\n\nComputes RMS bandwidth of a signal.\n\n\n\n\n\n","category":"method"},{"location":"basic.html#SignalAnalysis.rmsduration-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Basic signal analysis","title":"SignalAnalysis.rmsduration","text":"rmsduration(s)\n\n\nComputes RMS duration of the signal.\n\n\n\n\n\n","category":"method"},{"location":"array.html#Array-signal-processing","page":"Array signal processing","title":"Array signal processing","text":"","category":"section"},{"location":"array.html","page":"Array signal processing","title":"Array signal processing","text":"Modules = [SignalAnalysis]\nPages   = [\"array.jl\"]","category":"page"},{"location":"array.html#SignalAnalysis.Bartlett","page":"Array signal processing","title":"SignalAnalysis.Bartlett","text":"Frequency-domain Bartlett beamformer.\n\n\n\n\n\n","category":"type"},{"location":"array.html#SignalAnalysis.Capon","page":"Array signal processing","title":"SignalAnalysis.Capon","text":"Frequency-domain Capon beamformer with diagonal loading factor γ.\n\n\n\n\n\n","category":"type"},{"location":"array.html#SignalAnalysis.Music","page":"Array signal processing","title":"SignalAnalysis.Music","text":"Frequency-domain MUSIC beamformer with nsignals signals.\n\n\n\n\n\n","category":"type"},{"location":"array.html#SignalAnalysis.beamform-NTuple{4, Any}","page":"Array signal processing","title":"SignalAnalysis.beamform","text":"beamform(s, f, n, sd; fs=framerate(s), method=Bartlett())\nbeamform(s, f, sd; fs=framerate(s), method=Bartlett())\n\nNarrowband frequency-domain beamformer. Takes in passband signals s and produces beamformer output for all directions specified by the steering delays sd. The beamformer output is an energy estimate (or equivalent) for each steering direction. The beamforming only uses a narrowband signal cenetered at frequency f with a bandwidth of about fs/n.\n\nIf n is not specified, or is 1, then the input signal is assumed to be narrowband, and centered at frequency f.\n\nThe narrowband assumption requires that the bandwidth be no greater than about 5/T, where T is the maximum time taken for a signal to propagate through the array.\n\nSeveral beamforming methods are available:\n\nBartlett()\nCapon(γ)\nMusic(nsignals)\n\nCustom beamformers can be implemented by creating a subtype of SignalAnalysis.Beamformer and implementing the SignalAnalysis.beamformer() method dispatched on that type.\n\nExample:\n\njulia> x = cw(100.0, 1.0, 44100.0);\njulia> sd = steering(0.0:1.0:3.0, 1500.0, range(0.0, π; length=181));\njulia> bfo = beamform([x x x x], 100.0, 4096, sd; method=Capon(0.1))\n181-element Array{Float64,1}:\n 0.12406290296318974\n 0.1240975045516605\n ⋮\n 0.12406290296318974\n\n\n\n\n\n","category":"method"},{"location":"array.html#SignalAnalysis.beamform-Tuple{Any, Any}","page":"Array signal processing","title":"SignalAnalysis.beamform","text":"beamform(s, sd; fs=framerate(s))\n\nBroadband time-domain delay-and-sum beamformer. Takes in passband or baseband signals s and produces beamformer output for all directions specified by the steering delays sd. The beamformer output is a timeseries signal for each steering direction.\n\nExample:\n\njulia> x = cw(100.0, 1.0, 44100.0);\njulia> sd = steering(0.0:1.0:3.0, 1500.0, range(0.0, π; length=181));\njulia> bfo = beamform([x x x x], sd)\nSampledSignal @ 44100.0 Hz, 44100×181 Array{Complex{Float64},2}:\n  ⋮\n\n\n\n\n\n","category":"method"},{"location":"array.html#SignalAnalysis.steering-Tuple{AbstractMatrix{T} where T, Any, AbstractVector{T} where T}","page":"Array signal processing","title":"SignalAnalysis.steering","text":"steering(rxpos, c, θ)\n\n\nComputes steering delays for specified receiver positions rxpos, signal propagation speed c, and angles θ. Array θ can be a 1D array of angles or 2D array with (azimuth, elevation) pair in each row. The delays are computed with a far-field assumption, i.e., for plane incoming waves.\n\nExamples:\n\njulia> steering(0.0:1.0:5.0, 1500.0, range(0.0, π; length=181))\n6×181 Array{Float64,2}:\n  0.00166667    0.00166641   …  -0.00166641   -0.00166667\n  0.001         0.000999848     -0.000999848  -0.001\n  0.000333333   0.000333283     -0.000333283  -0.000333333\n -0.000333333  -0.000333283      0.000333283   0.000333333\n -0.001        -0.000999848      0.000999848   0.001\n -0.00166667   -0.00166641   …   0.00166641    0.00166667\n\njulia> rxpos = [  # can be 2D or 3D coordinates\n  0.0  1.0  2.0  3.0  4.0  5.0\n  0.0  0.0  0.0  0.0  0.0  0.0\n];\njulia> steering(rxpos, 1500.0, range(0.0, π; length=181))\n6×181 Array{Float64,2}:\n  0.00166667    0.00166641   …  -0.00166641   -0.00166667\n  0.001         0.000999848     -0.000999848  -0.001\n  0.000333333   0.000333283     -0.000333283  -0.000333333\n -0.000333333  -0.000333283      0.000333283   0.000333333\n -0.001        -0.000999848      0.000999848   0.001\n -0.00166667   -0.00166641   …   0.00166641    0.00166667\n\njulia> rxpos = [\n  0.0  0.0  0.5  0.5\n  0.0  0.5  0.0  0.5\n  0.0  0.0  0.0  0.0\n];\njulia> θ = deg2rad.(reduce(vcat, hcat.(LinRange(-20,20,41)', LinRange(-10,10,21)))) # 2D array with (azimuth, elevation) in each row\njulia> steering(rxpos, 1500.0, θ)\n4×861 Array{Float64,2}:\n  9.80987e-5    9.83857e-5    9.86427e-5  …   0.00021154   0.000210989   0.000210373\n  0.000210373   0.000210989   0.00021154      9.86427e-5   9.83857e-5    9.80987e-5\n -0.000210373  -0.000210989  -0.00021154     -9.86427e-5  -9.83857e-5   -9.80987e-5\n -9.80987e-5   -9.83857e-5   -9.86427e-5     -0.00021154  -0.000210989  -0.000210373\n\n\n\n\n\n","category":"method"},{"location":"plot.html#Plot-recipes","page":"Plot recipes","title":"Plot recipes","text":"","category":"section"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"Plot recipes are enabled by importing Plots:","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"using Plots","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"We provide a plot recipe to display signals:","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"plot(data::SampledSignal; t0=0.0, downsample=:auto, pooling=:auto, kwargs...)","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"Optional arguments:","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"t0=0.0: start time (for labeling only)\ndownsample=:auto: downsampling factor (integer or :auto)\npooling=:auto: pooling mode (:auto, :min, :max, :mean, :minmax, nothing or function)","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"If the signal is too long, it is automatically downsampled in a perceptually meaningful way. The downsampling can be controlled using the downsample and pooling keywords.","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"We also provide convenience plot recipes for common signal processing plots:","category":"page"},{"location":"plot.html","page":"Plot recipes","title":"Plot recipes","text":"psd\nspecgram\nfreqresp","category":"page"},{"location":"plot.html#SignalAnalysis.psd","page":"Plot recipes","title":"SignalAnalysis.psd","text":"psd(data; kwargs...)\n\nPlots the power spectral density of data.\n\nOptional keyword arguments\n\nfs=1.0: derived from the data if a SampledSignal is provided as input\nnfft=512: size of FFT window\nnoverlap=nfft÷2: window overlap size\nwindow=hamming(nfft): accepts any window from DSP.jl\nxscale=:auto: one of :auto, :identity or :log10\nyrange=50: y-scale dB range for automatic scaling\nother kwargs are passed on to plot\n\n\n\n\n\n","category":"function"},{"location":"plot.html#SignalAnalysis.specgram","page":"Plot recipes","title":"SignalAnalysis.specgram","text":"specgram(data; kwargs...)\n\nPlots a spectrogram of the data.\n\nOptional keyword arguments\n\nfs=1.0: derived from the data if a SampledSignal is provided as input\nnfft=256: size of FFT window\nnoverlap=nfft÷2: window overlap size\nwindow=hamming(nfft): accepts any window from DSP.jl\nt0=0.0: start time\ndownsample=:auto: downsampling factor (integer) for time axis\npooling=:mean: pooling mode (:min, :max, :mean, nothing or function)\ncrange=50: color scale dB range for automatic scaling\nother kwargs are passed on to plot\n\n\n\n\n\n","category":"function"},{"location":"signals.html#Creating-and-managing-signals","page":"Creating & managing signals","title":"Creating & managing signals","text":"","category":"section"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"Signals are represented by array-like data types with a series (time, frequency or space domain) per column. The SampledSignal data type wraps an array and carries sampling rate as metadata with it. This allows the API to be used without having to specify sampling rate at each call. However, if a user prefers to use other array-like data types, the sampling rate may be provided as a fs keyword argument for API calls that require sampling rate.","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"All code examples in this manual assume you have imported SignalAnalysis and SignalAnalysis.Units:","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"using SignalAnalysis, SignalAnalysis.Units","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"The SignalAnalysis.Units package re-exports commonly used units (s, ms, Hz, kHz, etc) from Unitful.jl. In addition, a variable 𝓈 is always exported and is an alias for the s unit from SignalAnalysis.Units. This allows indexing of signals using time in seconds:","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"# create a 1-second signal sampled at 20 kHz\nx = signal(randn(20000), 20kHz)\n\n# get a signal segment from 0.25 to 0.5 seconds:\ny = x[0.25:0.5𝓈]","category":"page"},{"location":"signals.html#Creating-and-wrapping-signals","page":"Creating & managing signals","title":"Creating and wrapping signals","text":"","category":"section"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"Signals wrapped in a SampledSignal data type may be easily created using signal():","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"x = signal(data, fs)","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"Properties such as frame rate (sampling rate), number of channels, etc may be accessed using the SignalBase API. The signals can be treated as arrays, but carry sampling rate metadata with them. While most operations infer metadata from the input signal, some operations may be unable to automatically infer the frame rate of the output signal. We provide some handy wrappers around common DSP.jl functions to aid with rate inference:","category":"page"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"# create a 1-second signal sampled at 20 kHz\ny = signal(randn(20000), 20kHz)\n\n# use DSP.filt() to filter a signal but retainin sampling rate\ny = sfilt(lpf, y)\n\n# use DSP.filtfilt() to filter a signal but retainin sampling rate\ny = sfiltfilt(lpf, y)\n\n# use DSP.resample() to resample a signal and infer sampling rate\ny = sresample(y, 2//3)","category":"page"},{"location":"signals.html#API-reference","page":"Creating & managing signals","title":"API reference","text":"","category":"section"},{"location":"signals.html","page":"Creating & managing signals","title":"Creating & managing signals","text":"Modules = [SignalAnalysis]\nPages   = [\"signals.jl\"]","category":"page"},{"location":"signals.html#Base.Colon-Tuple{Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Creating & managing signals","title":"Base.Colon","text":"(:)(start::Unitful.Time, stop::Unitful.Time)\n\nGenerates a time range index for a signal.\n\nExamples:\n\njulia> x = signal(randn(2000), 8kHz)\njulia> x[0.2𝓈:0.201𝓈]\nSampledSignal @ 8000.0 Hz, 9-element Array{Float64,1}:\n -0.08671384898800058\n -0.665143340284631\n -0.3955367460364236\n  1.2386430598616671\n -0.4882254309443194\n -1.080437097803303\n  0.8209785486953832\n  1.3477512734963886\n -0.27722340584395494\n\n\n\n\n\n","category":"method"},{"location":"signals.html#Base.Iterators.partition-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}, Integer}","page":"Creating & managing signals","title":"Base.Iterators.partition","text":"partition(x::SampledSignal, n; step=n, flush=true)\n\nIterates over the signal x, n samples at a time, with a step size of step. If flush is enabled, the last partition may be smaller than n samples.\n\nWhen applied to a multichannel signal x, each partition contains samples from all channels.\n\nExamples:\n\njulia> x = signal(collect(1:10), 1.0);\njulia> collect(partition(x, 5))\n2-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:\n [1, 2, 3, 4, 5]\n [6, 7, 8, 9, 10]\n\njulia> collect(partition(x, 5; step=2))\n5-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:\n [1, 2, 3, 4, 5]\n [3, 4, 5, 6, 7]\n [5, 6, 7, 8, 9]\n [7, 8, 9, 10]\n [9, 10]\n\njulia> collect(partition(x, 5; step=2, flush=false))\n3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:\n [1, 2, 3, 4, 5]\n [3, 4, 5, 6, 7]\n [5, 6, 7, 8, 9]\n\njulia> x = signal(hcat(collect(1:10), collect(11:20)), 1.0);\njulia> collect(partition(x, 5))[1]\n5×2 view(::Array{Int64,2}, 1:5, :) with eltype Int64:\n 1  11\n 2  12\n 3  13\n 4  14\n 5  15\n\n\n\n\n\n","category":"method"},{"location":"signals.html#Base.Libc.time-Tuple{Real, MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Creating & managing signals","title":"Base.Libc.time","text":"time(i, x::SampledSignal)\n\nGets the time of the ith sample in the signal. The index i can be a range or an array of indices.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.analytic-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Creating & managing signals","title":"SignalAnalysis.analytic","text":"analytic(s)\n\n\nConverts a signal to analytic representation. The conversion preserves energy, i.e., to convert back to a real signal while conserving energy, multiply by √2.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.domain-Tuple{Any}","page":"Creating & managing signals","title":"SignalAnalysis.domain","text":"domain(x)\n\n\nReturns the domain of the signal.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.isanalytic-Tuple{Any}","page":"Creating & managing signals","title":"SignalAnalysis.isanalytic","text":"isanalytic(s)\n\n\nChecks if a signal is analytic.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.issamerate-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}, MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Creating & managing signals","title":"SignalAnalysis.issamerate","text":"issamerate(x, y)\n\n\nChecks if two signals have the same sampling rate. If the sampling rate of a signal is unknown (because it is not a SampledSignal), it is assumed to have the same rate as the other signal.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.padded-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"Creating & managing signals","title":"SignalAnalysis.padded","text":"padded(s::AbstractArray{T, 2}, padding; delay, fill) -> Any\n\n\nGenerates a padded view of a signal with optional delay/advance.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.padded-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","page":"Creating & managing signals","title":"SignalAnalysis.padded","text":"padded(s::AbstractArray{T, 1}, padding; delay, fill) -> Any\n\n\nGenerates a padded view of a signal with optional delay/advance.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.samerateas-Tuple{Any, Any}","page":"Creating & managing signals","title":"SignalAnalysis.samerateas","text":"samerateas(x, y)\n\n\nCreate a signal with samples y and sampling rate same as signal x.\n\nExamples:\n\njulia> x = signal(randn(100), 8kHz)\njulia> y = samerateas(x, randn(5))\nSampledSignal @ 8000.0 Hz, 5-element Vector{Float64}:\n -0.3053704876108388\n -0.5474123820044299\n -0.6916442204609657\n -0.5185296405433826\n -0.4598263144701988\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.samerateas-Tuple{Any}","page":"Creating & managing signals","title":"SignalAnalysis.samerateas","text":"samerateas(x)\n\n\nCreate a signal with the same sampling rate as signal x.\n\nExamples:\n\njulia> x = signal(randn(100), 8kHz)\njulia> y = samerateas(x)(randn(5))\nSampledSignal @ 8000.0 Hz, 5-element Array{Float64,1}:\n -0.08671384898800058\n -0.665143340284631\n -0.3955367460364236\n 0.8209785486953832\n 1.3477512734963886\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.samples-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Creating & managing signals","title":"SignalAnalysis.samples","text":"samples(s)\n\n\nGets the underlying samples in the signal.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{AbstractArray, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(x::AbstractArray, fs) -> Any\n\n\nCreates a signal with frame rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{AbstractString}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(filename::AbstractString; start, nsamples) -> Any\n\n\nLoads a signal from a WAV file.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(fs) -> Any\n\n\nCreates a curried function that takes in an array and creates a signal with sampling rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{Int64, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(\n    n::Int64,\n    fs\n) -> MetaArrays.MetaArray{Vector{Float64}, SignalAnalysis.SamplingInfo, Float64, 1}\n\n\nCreates an empty signal of length n samples, and frame rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{Int64, Int64, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(\n    n::Int64,\n    ch::Int64,\n    fs\n) -> MetaArrays.MetaArray{Matrix{Float64}, SignalAnalysis.SamplingInfo, Float64, 2}\n\n\nCreates an empty signal of length n samples, ch channels, and frame rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(\n    x::MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N},\n    fs\n) -> Any\n\n\nCreates a signal with frame rate fs. If the original signal's frame rate is the same as fs, this method simply returns the original signal. Otherwise, it creates a new signal with the specified frame rate and data from the original signal. Do note that this method does not resample the signal.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{Type, Int64, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(\n    T::Type,\n    n::Int64,\n    fs\n) -> MetaArrays.MetaArray{_A, SignalAnalysis.SamplingInfo, _B, 1} where {_A, _B}\n\n\nCreates an empty signal of type T, length n samples, and frame rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.signal-Tuple{Type, Int64, Int64, Any}","page":"Creating & managing signals","title":"SignalAnalysis.signal","text":"signal(\n    T::Type,\n    n::Int64,\n    ch::Int64,\n    fs\n) -> MetaArrays.MetaArray{_A, SignalAnalysis.SamplingInfo, _B, 2} where {_A, _B}\n\n\nCreates an empty signal of type T, length n samples, ch channels, and frame rate fs.\n\n\n\n\n\n","category":"method"},{"location":"signals.html#SignalAnalysis.toframe-Tuple{Any, MetaArrays.MetaArray{var\"#s2\", SignalAnalysis.SamplingInfo, T, N} where {T, var\"#s2\", N}}","page":"Creating & managing signals","title":"SignalAnalysis.toframe","text":"toframe(t, s::SampledSignal)\ntoframe(t, fs)\n\nConverts time to signal frame number.\n\nExamples:\n\njulia> x = signal(randn(2000), 8kHz);\njulia> toframe(0.2𝓈, x)\n1601\n\njulia> toframe(0.2𝓈, 8kHz)\n1601\n\njulia> toframe([0.2𝓈, 0.201𝓈], x)\n2-element Array{Int64,1}:\n  1601\n  1609\n\njulia> toframe(0.2:0.201𝓈, x)\n1601:1609\n\njulia> toframe((0.2, 0.201), x)\n1601:1609\n\njulia> toframe((0.2, 0.201), 8000)\n1601:1609\n\njulia> toframe(0.2:0.01:0.3, x)\n11-element Array{Int64,1}:\n  1601\n  1681\n  1761\n   ⋮\n\n\n\n\n\n","category":"method"},{"location":"tfa.html#Time-frequency-analysis","page":"Time-frequency analysis","title":"Time-frequency analysis","text":"","category":"section"},{"location":"tfa.html","page":"Time-frequency analysis","title":"Time-frequency analysis","text":"Modules = [SignalAnalysis]\nPages   = [\"tfa.jl\"]","category":"page"},{"location":"tfa.html#SignalAnalysis.tfd-Tuple{Any, Spectrogram}","page":"Time-frequency analysis","title":"SignalAnalysis.tfd","text":"tfd(\n    s,\n    kernel::Spectrogram;\n    onesided,\n    fs\n) -> SignalAnalysis.TFD{_A} where _A\n\n\nComputes a spectrogram time-frequency distribution of signal s sampled as sampling rate fs.\n\nExamples:\n\njulia> x = real.(chirp(1kHz, 10kHz, 1s, 44.1kHz));\njulia> y = tfd(x, Spectrogram());\njulia> plot(y)\njulia> y = tfd(x, Spectrogram(nfft=512, noverlap=256, window=hamming));\njulia> plot(y)\n\n\n\n\n\n","category":"method"},{"location":"tfa.html#SignalAnalysis.tfd-Tuple{Any, Wigner}","page":"Time-frequency analysis","title":"SignalAnalysis.tfd","text":"tfd(\n    s,\n    kernel::Wigner;\n    onesided,\n    fs\n) -> SignalAnalysis.TFD{_A} where _A\n\n\nComputes a Wigner-Ville time-frequency distribution of signal s sampled as sampling rate fs.\n\nExamples:\n\njulia> x = real.(chirp(1kHz, 10kHz, 0.01s, 44.1kHz));\njulia> y = tfd(x, Wigner());\njulia> plot(y; clim=(0,20))\njulia> y = tfd(x, Wigner(nfft=512, smooth=10, method=:CM1980, window=hamming));\njulia> plot(y; clim=(0,20))\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#Signal-processing","page":"Signal processing","title":"Signal processing","text":"","category":"section"},{"location":"dsp.html","page":"Signal processing","title":"Signal processing","text":"Modules = [SignalAnalysis]\nPages   = [\"dsp.jl\"]","category":"page"},{"location":"dsp.html#SignalAnalysis.circconv","page":"Signal processing","title":"SignalAnalysis.circconv","text":"circconv(x)\ncircconv(x, y)\n\n\nComputes the circular convolution of x and y. Both vectors must be the same length.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.compose-Tuple{Any, Any, Any}","page":"Signal processing","title":"SignalAnalysis.compose","text":"compose(r, t, a; duration, fs)\n\n\nCompose a signal from a reference signal and a list of arrival times and amplitudes.\n\nExamples:\n\njulia> x = cw(10kHz, 0.01, 44.1kHz)\njulia> y1 = compose(x, [0.01, 0.03, 0.04], [1.0, 0.8, 0.6]; duration=0.05)\njulia> y2 = compose(real(x), [10ms, 30ms, 40ms], [1.0, 0.8, 0.6]; duration=50ms)\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.delay!-Tuple{Any, Integer}","page":"Signal processing","title":"SignalAnalysis.delay!","text":"delay!(x, v)\n\nDelay signal x by v units. The delay may be specified in samples or in time units (e.g. 2.3𝓈). The function supports delays of fractional or negative number of samples. The length of the returned signal is the same as the original, with any part of the signal that is shifted beyond the original length discarded.\n\nExamples:\n\njulia> x = signal([1.0, 2.0, 3.0], 10.0)\njulia> delay!(x, 1)\nSampledSignal @ 10.0 Hz, 3-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n\njulia> x = signal([1.0, 2.0, 3.0], 10.0)\njulia> delay!(x, -1)\nSampledSignal @ 10.0 Hz, 3-element Vector{Float64}:\n 1.0\n 2.0\n 0.0\n\njulia> x = signal([1.0, 2.0, 3.0, 2.0, 1.0], 10.0)\njulia> delay!(x, 1.2)\nSampledSignal @ 10.0 Hz, 5-element Vector{Float64}:\n -0.10771311593885118\n  0.8061269251734184\n  1.7488781412804602\n  2.9434587943152617\n  2.2755141401574472\n\njulia> x = signal([1.0, 2.0, 3.0, 2.0, 1.0], 10.0)\njulia> delay!(x, -0.11𝓈)\nSampledSignal @ 10.0 Hz, 5-element Vector{Float64}:\n  2.136038062052266\n  2.98570052268015\n  1.870314441196549\n  0.9057002486847239\n -0.06203155191384361\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.demon-Tuple{Any}","page":"Signal processing","title":"SignalAnalysis.demon","text":"demon(x; fs, downsample, method, cutoff)\n\n\nEstimates DEMON spectrum. The output is highpass filtered with a cutoff frequency and downsampled. Supported downsampling methods are :rms (default), :mean and :fir.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.downconvert","page":"Signal processing","title":"SignalAnalysis.downconvert","text":"downconvert(s, sps, fc)\ndownconvert(s, sps, fc, pulseshape; fs)\n\n\nConverts passband signal centered around carrier frequency fc to baseband, and downsamples it by a factor of sps. If the pulseshape is specified to be nothing, downsampling is performed without filtering.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.findsignal","page":"Signal processing","title":"SignalAnalysis.findsignal","text":"findsignal(r, s)\nfindsignal(r, s, n; prominance, coarse)\n\n\nFinds up to n copies of reference signal r in signal s. The reference signal r should have a delta-like autocorrelation for this function to work well. If the keyword parameter coarse is set to true, approximate arrival times are computed based on a matched filter. If it is set to false, an iterative optimization is performed to find more accruate arrival times.\n\nReturns named tuple (time=t, amplitude=a) where t is a vector of arrival times and a is a vector of complex amplitudes of the arrivals. The arrivals are sorted in ascending order of arrival times.\n\nExamples:\n\njulia> x = chirp(1000, 5000, 0.1, 40960; window=(tukey, 0.05))\njulia> x4 = resample(x, 4)\njulia> y4 = samerateas(x4, zeros(32768))\njulia> y4[128:127+length(x4)] = real(x4)          # time 0.000775𝓈, index 32.75\njulia> y4[254:253+length(x4)] += -0.8 * real(x4)  # time 0.001544𝓈, index 64.25\njulia> y4[513:512+length(x4)] += 0.6 * real(x4)   # time 0.003125𝓈, index 129.0\njulia> y = resample(y4, 1//4)\njulia> y .+= 0.1 * randn(length(y))\njulia> findsignal(x, y, 3; coarse=true)\n(time = Float32[0.000781, 0.001538, 0.003125], amplitude = ComplexF64[...])\njulia> findsignal(x, y, 3)\n(time = Float32[33, 64, 129], [0.000775, 0.001545, 0.003124], amplitude = ComplexF64[...])\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.fir","page":"Signal processing","title":"SignalAnalysis.fir","text":"fir(n, f1)\nfir(n, f1, f2; fs, method)\n\n\nDesigns a n-tap FIR filter with a passband from f1 to f2 using the specified method. If frame rate fs is not specified, f1 and f2 are given in normalized units (1.0 being Nyquist). If f1 is 0, the designed filter is a lowpass filter, and if f2 is nothing then it is a highpass filter.\n\nThis method is a convenience wrapper around DSP.digitalfilter.\n\nExamples:\n\njulia> lpf = fir(127, 0, 10kHz; fs=44.1kHz)   # design a lowpass filter\n127-element Array{Float64,1}:\n  ⋮\n\njulia> hpf = fir(127, 10kHz; fs=44.1kHz)      # design a highpass filter\n127-element Array{Float64,1}:\n  ⋮\n\njulia> bpf = fir(127, 1kHz, 5kHz; fs=44.1kHz) # design a bandpass filter\n127-element Array{Float64,1}:\n  ⋮\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.gmseq","page":"Signal processing","title":"SignalAnalysis.gmseq","text":"gmseq(m)\ngmseq(m, θ)\n\n\nGenerates an generalized m-sequence of length 2^m-1 or tap specification m.\n\nGeneralized m-sequences are related to m-sequences but have an additional parameter θ. When θ = π/2, generalized m-sequences become normal m-sequences. When θ < π/2, generalized m-sequences contain a DC-component that leads to an exalted carrier after modulation. When θ is atan(√(2^m-1)), the m-sequence is considered to be period matched. Period matched m-sequences are complex sequences with perfect discrete periodic auto-correlation properties, i.e., all non-zero lag periodic auto-correlations are zero. The zero-lag autocorrelation is 2^m-1, where m is the shift register length.\n\nThis function currently supports shift register lengths between 2 and 30.\n\nExamples:\n\njulia> x = gmseq(3)         # generate period matched m-sequence\n7-element Array{Complex{Float64},1}:\n 0.3535533905932738 + 0.9354143466934853im\n 0.3535533905932738 + 0.9354143466934853im\n 0.3535533905932738 + 0.9354143466934853im\n 0.3535533905932738 - 0.9354143466934853im\n 0.3535533905932738 + 0.9354143466934853im\n 0.3535533905932738 - 0.9354143466934853im\n 0.3535533905932738 - 0.9354143466934853im\n\njulia> x = gmseq(3, π/4)    # generate m-sequence with exalted carrier\n7-element Array{Complex{Float64},1}:\n 0.7071067811865476 + 0.7071067811865475im\n 0.7071067811865476 + 0.7071067811865475im\n 0.7071067811865476 + 0.7071067811865475im\n 0.7071067811865476 - 0.7071067811865475im\n 0.7071067811865476 + 0.7071067811865475im\n 0.7071067811865476 - 0.7071067811865475im\n 0.7071067811865476 - 0.7071067811865475im\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.goertzel-Tuple{AbstractVector{T} where T, Any, Any}","page":"Signal processing","title":"SignalAnalysis.goertzel","text":"goertzel(x, f, n; fs)\n\n\nDetects frequency f in input signal using the Goertzel algorithm.\n\nThe detection metric returned by this function is the complex output of the Goertzel filter at the end of the input block. Typically, you would want to compare the magnitude of this output with a threshold to detect a frequency.\n\nWhen a block size n is specified, the Goertzel algorithm in applied to blocks of data from the original time series.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.istft-Union{Tuple{T}, Tuple{Type{var\"#s3\"} where var\"#s3\"<:Real, AbstractArray{Complex{T}, 2}}} where T<:AbstractFloat","page":"Signal processing","title":"SignalAnalysis.istft","text":"istft(, X; nfft, noverlap, window)\n\n\nCompute the inverse short time Fourier transform (ISTFT) of one-sided STFT coefficients X which is based on segments with nfft samples with overlap of noverlap samples. Refer to DSP.Periodograms.spectrogram for description of the parameters.\n\nFor perfect reconstruction, the parameters nfft, noverlap and window in stft and istft have to be the same, and the windowing must obey the constraint of \"nonzero overlap add\" (NOLA). Implementation based on Zhivomirov 2019 and istft in scipy.\n\nExamples:\n\njulia> x = randn(1024)\n1024-element Array{Float64,1}:\n -0.7903319156212055\n -0.564789077302601\n  0.8621044972211616\n  0.9351928359709288\n  ⋮\n  2.6158861993992533\n  1.2980813993011973\n -0.010592954871694647\n\njulia> X = stft(x, 64, 0)\n33×31 Array{Complex{Float64},2}:\n  ⋮\n\njulia> x̂ = istft(Real, X; nfft=64, noverlap=0)\n1024-element Array{Float64,1}:\n -0.7903319156212054\n -0.5647890773026012\n  0.8621044972211612\n  0.9351928359709288\n  ⋮\n  2.6158861993992537\n  1.2980813993011973\n -0.010592954871694371\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.istft-Union{Tuple{T}, Tuple{Type{var\"#s5\"} where var\"#s5\"<:Complex, AbstractArray{Complex{T}, 2}}} where T<:AbstractFloat","page":"Signal processing","title":"SignalAnalysis.istft","text":"istft(, X; nfft, noverlap, window)\n\n\nCompute the inverse short time Fourier transform (ISTFT) of two-sided STFT coefficients X which is based on segments with nfft samples with overlap of noverlap samples. Refer to DSP.Periodograms.spectrogram for description of the parameters.\n\nFor perfect reconstruction, the parameters nfft, noverlap and window in stft and istft have to be the same, and the windowing must obey the constraint of \"nonzero overlap add\" (NOLA). Implementation based on Zhivomirov 2019 and istft in scipy.\n\nExamples:\n\njulia> x = randn(Complex{Float64}, 1024)\n1024-element Array{Complex{Float64},1}:\n  -0.5540372432417755 - 0.4286434695080883im\n  -0.4759024596520576 - 0.5609424987802376im\n                      ⋮\n -0.26493959584225923 - 0.28333817822701457im\n  -0.5294529732365809 + 0.7345044619457456im\n\njulia> X = stft(x, 64, 0)\n64×16 Array{Complex{Float64},2}:\n  ⋮\n\njulia> x̂ = istft(Complex, X; nfft=64, noverlap=0)\n1024-element Array{Complex{Float64},1}:\n  -0.5540372432417755 - 0.4286434695080884im\n -0.47590245965205774 - 0.5609424987802374im\n                      ⋮\n  -0.2649395958422591 - 0.28333817822701474im\n  -0.5294529732365809 + 0.7345044619457455im\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.mfilter-Tuple{Any, Any}","page":"Signal processing","title":"SignalAnalysis.mfilter","text":"mfilter(r, s)\n\n\nMatched filter looking for reference signal r in signal s.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.mseq","page":"Signal processing","title":"SignalAnalysis.mseq","text":"mseq(m)\nmseq(m, θ)\n\n\nGenerates an m-sequence of length 2^m-1 or tap specification m.\n\nm-sequences are sequences of +1/-1 values with near-perfect discrete periodic auto-correlation properties. All non-zero lag periodic auto-correlations are -1. The zero-lag autocorrelation is 2^m-1, where m is the shift register length.\n\nThis function currently supports shift register lengths between 2 and 30.\n\nExamples:\n\njulia> x = mseq(3)                  # generate regular m-sequence\n7-element Array{Float64,1}:\n  1.0\n  1.0\n  1.0\n -1.0\n  1.0\n -1.0\n -1.0\n\njulia> x = mseq((1,3))              # generate m-sequence with specification (1,3)\n7-element Array{Float64,1}:\n  1.0\n  1.0\n  1.0\n -1.0\n  1.0\n -1.0\n -1.0\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.pll","page":"Signal processing","title":"SignalAnalysis.pll","text":"pll(x)\npll(x, bandwidth; fs)\n\n\nPhased-lock loop to track dominant carrier frequency in input signal.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.rcosfir","page":"Signal processing","title":"SignalAnalysis.rcosfir","text":"rcosfir(β, sps)\nrcosfir(β, sps, span)\n\n\nRaised cosine filter.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.removedc!-Tuple{Any}","page":"Signal processing","title":"SignalAnalysis.removedc!","text":"removedc!(s; α)\n\n\nDC removal filter. Parameter α controls the cutoff frequency. Implementation based on Lyons 2011 (3rd ed) real-time DC removal filter in Fig. 13-62(d).\n\nSee also: removedc\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.removedc-Tuple{Any}","page":"Signal processing","title":"SignalAnalysis.removedc","text":"removedc(s; α)\n\n\nDC removal filter. Parameter α controls the cutoff frequency. Implementation based on Lyons 2011 (3rd ed) real-time DC removal filter in Fig. 13-62(d).\n\nSee also: removedc!\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.rrcosfir","page":"Signal processing","title":"SignalAnalysis.rrcosfir","text":"rrcosfir(β, sps)\nrrcosfir(β, sps, span)\n\n\nRoot-raised cosine filter.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.sfilt-Tuple{AbstractVector{var\"#s8\"} where var\"#s8\"<:Number, AbstractVector{T} where T}","page":"Signal processing","title":"SignalAnalysis.sfilt","text":"sfilt(f, x[, si])\nfilt(f, x::SampledSignal[, si])\nsfilt(b, a, x[, si])\nfilt(b, a, x::SampledSignal[, si])\n\nSame as filt, but retains sampling rate information.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.sfiltfilt-Tuple{Any, Any}","page":"Signal processing","title":"SignalAnalysis.sfiltfilt","text":"sfiltfilt(coef, x)\nfiltfilt(coef, x::SampledSignal)\n\nSame as filtfilt, but retains sampling rate information.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.sresample-Tuple{Any, Any}","page":"Signal processing","title":"SignalAnalysis.sresample","text":"sresample(x, rate[, coef])\nresample(x::SampledSignal, rate[, coef])\n\nSame as resample, but correctly handles sampling rate conversion.\n\n\n\n\n\n","category":"method"},{"location":"dsp.html#SignalAnalysis.upconvert","page":"Signal processing","title":"SignalAnalysis.upconvert","text":"upconvert(s, sps, fc)\nupconvert(s, sps, fc, pulseshape; fs)\n\n\nConverts baseband signal with sps symbols per passband sample to a real passband signal centered around carrier frequency fc.\n\n\n\n\n\n","category":"function"},{"location":"dsp.html#SignalAnalysis.whiten-Tuple{AbstractVector{T} where T}","page":"Signal processing","title":"SignalAnalysis.whiten","text":"whiten(x; nfft, noverlap, window, γ)\n\n\nSpectral whitening of input signal x in the frequency domain. The parameters nfft, noverlap and window are required for the computation of STFT coefficients of x. Refer to DSP.Periodograms.spectrogram for description of the parameters. γ is a scaling or degree-of-flattening factor. The algorithm is based on Lee 1986.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SignalAnalysis.jl","page":"Home","title":"SignalAnalysis.jl","text":"","category":"section"},{"location":"index.html#Signal-analysis-toolbox-for-Julia","page":"Home","title":"Signal analysis toolbox for Julia","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = SignalAnalysis","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"While a few great signal processing packages (e.g. DSP.jl, SignalOperators.jl) are available, they have limited time-frequency analysis, sonar analysis, and baseband analysis capabilities. This SignalAnalysis.jl package aims to fill that gap. The package has grown out of my research needs, but I hope to expand it over time to provide a wide variety of time-frequency analysis, and baseband signal processing tools.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"While this package works with most array-like data types, it uses the SignalBase.jl API to represent multichannel 1D signals (time, frequency or spatial domain). While the package adopts a SampledSignal data type to carry sampling rate information with the sampled signal, the API design allows sampling rate to be provided as a keyword argument in most cases, enabling the user to pass in any array-like data.","category":"page"},{"location":"index.html#APIs","page":"Home","title":"APIs","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Creating & managing signals\nGenerating signals\nBasic signal analysis\nSignal processing\nTime-frequency analysis\nArray signal processing\nRandom noise generation\nPlot recipes\nInteractive plotting","category":"page"},{"location":"index.html#Quick-links","page":"Home","title":"Quick links","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"SignalAnalysis.jl\nSignalBase.jl\nDSP.jl\nPlots.jl\nUnitful.jl","category":"page"},{"location":"rand.html#Random-noise-generation","page":"Random noise generation","title":"Random noise generation","text":"","category":"section"},{"location":"rand.html","page":"Random noise generation","title":"Random noise generation","text":"PinkGaussian\nRedGaussian","category":"page"},{"location":"rand.html#SignalAnalysis.PinkGaussian","page":"Random noise generation","title":"SignalAnalysis.PinkGaussian","text":"struct PinkGaussian{T} <: Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}\n\nPink Gaussian noise distribution for random variate generation.\n\nExample:\n\njulia> rand(PinkGaussian(1000))\n1000-element Array{Float64,1}:\n   ⋮\n\njulia> rand(PinkGaussian(1000, 2.0))\n1000-element Array{Float64,1}:\n   ⋮\n\n\n\n\n\n","category":"type"},{"location":"rand.html#SignalAnalysis.RedGaussian","page":"Random noise generation","title":"SignalAnalysis.RedGaussian","text":"struct RedGaussian{T} <: Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}\n\nRed Gaussian noise distribution for random variate generation.\n\nExample:\n\njulia> rand(RedGaussian(1000))\n1000-element Array{Float64,1}:\n   ⋮\n\njulia> rand(RedGaussian(1000, 2.0))\n1000-element Array{Float64,1}:\n   ⋮\n\n\n\n\n\n","category":"type"}]
}
